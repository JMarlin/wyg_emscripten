{"version":3,"file":"wyg_test.js","sources":["main.c","wygwrap.c","list.c","rect.c","gfx.c","p5.c","entry.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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","sourcesContent":["#ifdef HARNESS_TEST\n#include \"../p5-redux/P5OSPPB/mods/include/gfx.h\"\n#include \"../p5-redux/P5OSPPB/mods/include/p5.h\"\n#include \"../p5-redux/P5OSPPB/mods/include/key.h\"\n#include <stdlib.h>\n#include <memory.h>\n#include <stdio.h>\n#include <emscripten.h>\n#include \"../p5-redux/P5OSPPB/mods/include/wyg.h\"\n#define REGISTRAR_PID 0\n#define REG_DEREGISTER 0\n#define SVC_WYG 0\nextern char* font_array;\nextern void testMain();\n#else \n#include \"../include/p5.h\"\n#include \"../include/registrar.h\"\n#include \"../include/gfx.h\"\n#include \"../include/memory.h\"\n#include \"../include/wyg.h\"\n#include \"../include/key.h\"\n#include \"../include/mouse.h\"\n#include \"../vesa/font.h\"\n#endif //HARNESS_TEST\n#include \"list.h\"\n#include \"rect.h\"\n\n#define FRAME_SIZE_TOP 28\n#define FRAME_SIZE_LEFT 4\n#define FRAME_SIZE_BOTTOM 4\n#define FRAME_SIZE_RIGHT 4\n#define MOUSE_WIDTH 12\n#define MOUSE_HEIGHT 12\n\n/* Windows are logically arranged as follows:\ndesktop.first_child:  window_a.first_child:  button_1.first_child:  -\n       .next_sibling:         .next_sibling: window_b.first_child:  button_2.first_child:  -\n                                                     .next_sibling: -       .next_sibling: button_3.first_child:  -\n                                                                                                   .next_sibling: textbox_1.first_child:  -\n                                                                                                                           .next_sibling: -\n                                                                                                                           \nLinkage is in order of increasing z-value                                                                                                \n*/\n\n#define new(x) (((x)*)malloc(sizeof(x)))\n\nvoid window_printer(void* value);\n\nmessage temp_msg;\n\nunsigned char inbuf[12];\n\ntypedef struct window {\n\tunsigned char active;\n    unsigned char flags;\n    unsigned int handle;\n    unsigned int pid;\n    bitmap* context;\n    unsigned int w;\n    unsigned int h;\n    unsigned int x;\n    unsigned int y;\n    unsigned char needs_redraw;\n    unsigned char* title;\n    unsigned char frame_needs_redraw;\n} window;\n\nwindow *root_window, *mouse_window;\nList* window_list;\nunsigned char inited = 0;\nbitmap* old_mouse_bkg;\nunsigned short mouse_x;\nunsigned short mouse_y;\nunsigned char mouse_buffer_ok = 0;\n\n/*!!!!!!!!!! DEBUG SHIT !!!!!!!!!\nunsigned char cmd_x;\nint cmd_width;\nint cmd_max_chars;\n\nvoid drawCharacter(char c, int x, int y, unsigned int color) {\n\n    setCursor(x, y);\n    setColor(color);\n    drawChar(c);\n}\n\nvoid cmd_pchar(unsigned char c) {\n\n    if(!inited || cmd_x > cmd_max_chars)\n        return;\n\n\tdrawCharacter(c, (cmd_x*8) + 1, 1, RGB(0, 0, 0));\n\tcmd_x++;    \n}\n\nvoid cmd_prints(unsigned char* s) {\n\n    if(!inited)\n        return;\n\n    setCursor(0, 0);\n    setColor(RGB(255, 255, 255));\n    fillRect(cmd_width, 14);    \n\n    cmd_x = 0;\n\n    while(*s)\n        cmd_pchar(*s++);\n}\n\nvoid cmd_printDecimal(unsigned int dword) {\n\n    unsigned char digit[12];\n    int i, j;\n\n    i = 0;\n    while(1) {\n\n        if(!dword) {\n\n            if(i == 0)\n                digit[i++] = 0;\n\n            break;\n        }\n\n        digit[i++] = dword % 10;\n        dword /= 10;\n    }\n\n    for(j = i - 1; j >= 0; j--)\n        cmd_pchar(digit[j] + '0');\n}\n\nvoid cons_init();\nvoid cons_putc(char c);\nvoid cons_prints(char* s);\nvoid cons_printDecimal(unsigned int dword);\nvoid cons_printHexByte(unsigned char byte);\nvoid cons_printHexWord(unsigned short wd);\nvoid cons_printHexDword(unsigned int dword);\n\nvoid cmd_printHexByte(unsigned char byte) {\n\n    cmd_pchar(digitToHex((byte & 0xF0)>>4));\n    cmd_pchar(digitToHex(byte & 0xF));\n}\n\n\nvoid cmd_printHexWord(unsigned short wd) {\n\n    cmd_printHexByte((unsigned char)((wd & 0xFF00)>>8));\n    cmd_printHexByte((unsigned char)(wd & 0xFF));\n}\n\n\nvoid cmd_printHexDword(unsigned int dword) {\n\n    cmd_printHexWord((unsigned short)((dword & 0xFFFF0000)>>16));\n    cmd_printHexWord((unsigned short)(dword & 0xFFFF));\n}\n\nvoid cmd_init(unsigned short xres, unsigned short yres) {\n\n    cmd_x = 0;\n    cmd_width = xres;\n    cmd_max_chars = ((cmd_width - 2)/8) - 1;\n    inited = 1;\n}\n!!!!!!!!!! DEBUG SHIT !!!!!!!!!*/\n\nvoid drawWindow(window* cur_window, unsigned char use_current_blit);\nvoid raiseWindow(window* dest_window);\nvoid drawFrame(window* cur_window);\nvoid drawTitlebar(window* cur_window, int do_refresh);\n\nvoid bmpDrawHLine(bitmap* bmp, int x, int y, int length, unsigned int color) {\n\n    int i, endx;\n\n    endx = x + length;\n\n    for(i = x; i < endx; i++)\n        bmp->data[y*bmp->width + i] = color;\n}\n\nvoid bmpDrawVLine(bitmap* bmp, int x, int y, int length, unsigned int color) {\n\n    int i, endy;\n\n    endy = length + y;\n\n    for(i = y; i < endy; i++)\n        bmp->data[i*bmp->width + x] = color;\n}\n\n\nvoid bmpDrawRect(bitmap* bmp, int x, int y, int width, int height, unsigned int color) {\n\n    bmpDrawHLine(bmp, x, y, width, color);\n    bmpDrawVLine(bmp, x, y, height, color);\n    bmpDrawHLine(bmp, x, y + height - 1, width, color);\n    bmpDrawVLine(bmp, x + width - 1, y, height, color);\n}\n\n\nvoid bmpFillRect(bitmap* bmp, int x, int y, int width, int height, unsigned int color) {\n\n    int j, i;\n    int endx, endy;\n\n    endx = width + x;\n    endy = height + y;\n\n    //for(i = 0; i < (bmp->height*bmp->width); i++)\n    //    bmp->data[i] = RGB(255, 0, 0);\n\n    //return;\n\n    for(i = y; i < endy; i++) {\n\n        for(j = x; j < endx; j++) {\n\n            bmp->data[i*bmp->width + j] = color; \n        }\n    }\n}\n\n\nvoid bmpDrawCharacter(bitmap* bmp, unsigned char c, int x, int y, unsigned int color) {\n\n    return;\n\n    int j, i;\n    unsigned char line;\n    c = c & 0x7F; //Reduce to base ASCII set\n\n    for(i = 0; i < 12; i++) {\n\n        //prints(\"Reading a line from font cache...\");\n        line = font_array[i * 128 + c];\n        //prints(\"done\\n\");\n        for(j = 0; j < 8; j++) {\n            \n            if(line & 0x80) bmp->data[(y + i)*bmp->width + (x + j)] = color; \n            line = line << 1;\n        }\n    }\n}\n\nvoid displayString(int x, int y, unsigned char* s) {\n        \n    while((*s)) {\n        \n        setCursor(x, y);\n        drawChar(*(s++));\n        \n        x += 8;\n    }\n}\n\nvoid scans(int c, char* b) {\n\n    unsigned char temp_char;\n    int index = 0;\n\n    for(index = 0 ; index < c-1 ; ) {\n        temp_char = getch();\n\n        if(temp_char != 0) {\n            b[index] = temp_char;\n            pchar(b[index]);\n\n            if(b[index] == '\\n') {\n                b[index] = 0;\n                break;\n            }\n\n            index++;\n\n            if(index == c-1)\n                pchar('\\n');\n        }\n    }\n\n    b[index+1] = 0;\n}\n\n//#define RECT_TEST 1\nvoid drawBmpRect(window* win, Rect* r) {\n\n#ifdef RECT_TEST \n  \n    setColor(RGB(0, 255, 0));\n    setCursor(r->left, r->top);\n    drawRect(r->right - r->left, r->bottom - r->top);\n    \n#else     \n \n    //Adjust the rectangle coordinate from global space to window space \n    win->context->top = r->top - win->y;\n    win->context->left = r->left - win->x;\n    win->context->bottom = r->bottom - win->y;\n    win->context->right = r->right - win->x;   \n    \n    //Do the blit\n    setCursor(win->x, win->y);\n    drawBitmap(win->context);\n#endif //RECT_TEST\n}\n\nList* splitRect(Rect* rdest, Rect* rknife) {\n\t\n\tRect baserect;\n\tList* outrect;\n\tRect* new_rect;\n\t\n\tbaserect.top = rdest->top;\n\tbaserect.left = rdest->left;\n\tbaserect.bottom = rdest->bottom;\n\tbaserect.right = rdest->right;\n\t\n/*\n\tcons_prints(\"Splitting rect (\");\n\tcons_printDecimal(rdest->top);\n\tcons_prints(\", \");\n\tcons_printDecimal(rdest->left);\n\tcons_prints(\", \");\n\tcons_printDecimal(rdest->bottom);\n\tcons_prints(\", \");\n\tcons_printDecimal(rdest->right);\n\tcons_prints(\") with (\");   \n\tcons_printDecimal(rknife->top);\n\tcons_prints(\", \");\n\tcons_printDecimal(rknife->left);\n\tcons_prints(\", \");\n\tcons_printDecimal(rknife->bottom);\n\tcons_prints(\", \");\n\tcons_printDecimal(rknife->right);\n\tcons_prints(\")\\n\");\n*/\n\t\n#ifdef RECT_TEST    \n    //printf(\"splitting (%u, %u, %u, %u)\", baserect.top, baserect.left, baserect.bottom, baserect.right);\n    //printf(\"against (%u, %u, %u, %u)\\n\", rknife.top, rknife.left, rknife.bottom, rknife.right);\n#endif //RECT_TEST\n\t\t\n    //prints(\"Allocating space for \");\n     //printDecimal(sizeof(rect)*rect_count);\n    //prints(\" rect bytes\\n\");\n\toutrect = List_new();\n    if(!outrect) {\n\t\t\n        prints(\"Couldn't allocate rect space\\n\");\n\t\treturn outrect;\n\t}\n\t\n//    cons_prints(\"Doing left edge split\\n\");\n\t//Split by left edge\n\tif(rknife->left > baserect.left && rknife->left < baserect.right) {\n\t\t\n\t\tnew_rect = Rect_new(baserect.top, baserect.left, baserect.bottom, rknife->left - 1);\n\t\t\n\t\tif(!new_rect) {\n\t\t\t\n\t\t\tList_delete(outrect, Rect_deleter);\n\t\t\treturn (List*)0;\n\t\t}\n\t\t\n\t\tif(!List_add(outrect, new_rect)) {\n\t\t\t\n\t\t\tfree((void*)new_rect);\n\t\t\tList_delete(outrect, Rect_deleter);\n\t\t\treturn (List*)0;\n\t\t}\n\t\t\n\t\tbaserect.left = rknife->left;\n\t}\n\n//    cons_prints(\"Doing top edge split\\n\");\n\t//Split by top edge\n\tif(rknife->top < baserect.bottom && rknife->top > baserect.top) {\n\t\t\n\t\tnew_rect = Rect_new(baserect.top, baserect.left, rknife->top - 1, baserect.right);\n\t\t\n\t\tif(!new_rect) {\n\t\t\t\n\t\t\tList_delete(outrect, Rect_deleter);\n\t\t\treturn (List*)0;\n\t\t}\n\t\t\n\t\tif(!List_add(outrect, new_rect)) {\n\t\t\t\n\t\t\tfree((void*)new_rect);\n\t\t\tList_delete(outrect, Rect_deleter);\n\t\t\treturn (List*)0;\n\t\t}\n\t\t\n\t\tbaserect.top = rknife->top;\n\t}\n\n//    cons_prints(\"Doing right edge split\\n\");\n\t//Split by right edge\n\tif(rknife->right > baserect.left && rknife->right < baserect.right) {\n\t\t\n\t\tnew_rect = Rect_new(baserect.top, rknife->right + 1, baserect.bottom, baserect.right);\n\t\t\n\t\tif(!new_rect) {\n\t\t\t\n\t\t\tList_delete(outrect, Rect_deleter);\n\t\t\treturn (List*)0;\n\t\t}\n\t\t\n\t\tif(!List_add(outrect, new_rect)) {\n\t\t\t\n\t\t\tfree((void*)new_rect);\n\t\t\tList_delete(outrect, Rect_deleter);\n\t\t\treturn (List*)0;\n\t\t}\n\t\t\n\t\tbaserect.right = rknife->right;\n\t}\n\n//    cons_prints(\"Doing bottom edge split\\n\");\n\t//Split by bottom edge\n\tif(rknife->bottom > baserect.top && rknife->bottom < baserect.bottom) {\n\t\t\n\t\tnew_rect = Rect_new(rknife->bottom + 1, baserect.left, baserect.bottom, baserect.right);\n\t\t\n\t\tif(!new_rect) {\n\t\t\t\n\t\t\tList_delete(outrect, Rect_deleter);\n\t\t\treturn (List*)0;\n\t\t}\n\t\t\n\t\tif(!List_add(outrect, new_rect)) {\n\t\t\t\n\t\t\tfree((void*)new_rect);\n\t\t\tList_delete(outrect, Rect_deleter);\n\t\t\treturn (List*)0;\n\t\t}\n\t\t\n\t\tbaserect.bottom = rknife->bottom;\n\t}\n\n/*    cons_prints(\"Result: \\n\");\n\t\n\tList_for_each(outrect, new_rect, Rect*) {\n\t\n\t    cons_prints(\"    \");\n\t\tcons_printDecimal(new_rect->top);\n\t\tcons_prints(\", \");\n\t\tcons_printDecimal(new_rect->left);\n\t\tcons_prints(\", \");\n\t\tcons_printDecimal(new_rect->bottom);\n\t\tcons_prints(\", \");\n\t\tcons_printDecimal(new_rect->right);\n\t\tcons_prints(\"\\n\");\n\t}\n\t\n\tscans(10, inbuf);\n*/\n\treturn outrect;\t\n}\n\nvoid drawOccluded(window* win, Rect* baserect, List* splitrect_list) {\n\t\n\tif(!splitrect_list) \n\t\treturn;\n\t\n\tint split_count = 0;\n\tint total_count = 1;\n\tint working_total = 0;\n\tList* out_rects;\n\tRect* working_rects = (Rect*)0;\n\tint i, j, k;\n    Rect *new_rect, *rect, *split_rect, *out_rect;\n\t\t\n#ifdef RECT_TEST\n\t\n    //Clear everything \n    setColor(RGB(255, 255, 255));\n    setCursor(0, 0);\n    fillRect(root_window->context->width, root_window->context->height);\n    \n    //Draw the base window\n    setColor(RGB(0, 0, 255));\n    setCursor(baserect->left, baserect->top);\n    drawRect(baserect->right - baserect->left, baserect->bottom - baserect->top);\n    \n    //Draw the overlapping windows\n    List_for_each(splitrect_list, rect, Rect*) {\n        \n        setColor(RGB(255, 0, 0));\n        setCursor(rect->left, rect->top);\n        drawRect(rect->right - rect->left, rect->bottom - rect->top);\n    }\n    \n#endif //RECT_TEST\n    \n    //If there's nothing occluding us, just render the bitmap and get out of here\n    if(!splitrect_list->count) {\n\t\t\n        drawBmpRect(win, baserect);\n        return;\n    }\n    \n    //prints(\"[WYG] Allocating space for output rectangles\\n\");\n\tout_rects = List_new();\n    \n    if(!out_rects) {\n        \n        //prints(\"[WYG] Couldn't allocate space for output rect list\\n\");\n\t\treturn;\n    }\n    \n    rect = Rect_new(baserect->top, baserect->left, baserect->bottom, baserect->right);\n    \n    if(!rect) {\n        \n        //prints(\"[WYG] Couldn't allocate space for temp rectangle\\n\");\n\t\tList_delete(out_rects, Rect_deleter);\n        return;\n    }\n    \n    if(!List_add(out_rects, (void*)rect)) {\n        \n        //prints(\"[WYG] Couldn't insert out rect into list\\n\");\n\t\tfree((void*)rect);\n\t\tList_delete(out_rects, Rect_deleter);\n        return;\n    }\n\t\t        \n\t//For each splitting rect, split each rect in out_rects, delete the rectangle that was split, and add the resultant split rectangles\n\tList_for_each(splitrect_list, split_rect, Rect*) {\n\t\t\n\t\tList_for_each(out_rects, out_rect, Rect*) {\n            \n\t\t\tif((split_rect->left <= out_rect->right &&\n\t\t\t   split_rect->right >= out_rect->left &&\n\t\t\t   split_rect->top <= out_rect->bottom && \n\t\t\t   split_rect->bottom >= out_rect->top)) {\n\t\t\t    \n                List* clip_list = splitRect(out_rect, split_rect);\n\n#ifdef RECT_TEST\n\t\t\t            \n                //for(k = 0; k < split_count; k++)\n                    //printf(\"split %u, %u, %u, %u\\n\", split_rects[k].top, split_rects[k].left, split_rects[k].bottom, split_rects[k].right);\n\n#endif //RECT_TEST\n            \n\t\t\t    if(!clip_list) {\n\t\t\t\t\t\n\t\t\t\t\tList_delete(out_rects, Rect_deleter);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\n\t\t\t\t//If nothing was returned, we actually want to clip a rectangle in its entirety\n\t\t\t\tif(!clip_list->count) {\n\t\t\t\t\t\n\t\t\t\t\tList_remove(out_rects, (void*)out_rect, Rect_deleter);\n\t\t\t\t\t\n\t\t\t\t\t//If we deleted the last output rectangle, we are completely \n\t\t\t\t\t//occluded and can return early\n\t\t\t\t\tif(out_rects->count == 0) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tList_delete(clip_list, Rect_deleter);\n\t\t\t\t\t\tList_delete(out_rects, Rect_deleter);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//Otherwise, go back to the top of the loop and test the next out_rect\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t//Replace the rectangle that got split with the first result rectangle \n\t\t\t\trect = (Rect*)List_get_at(clip_list, 0);\n\t\t\t\tout_rect->top = rect->top;\n\t\t\t\tout_rect->left = rect->left;\n\t\t\t\tout_rect->bottom = rect->bottom;\n\t\t\t\tout_rect->right = rect->right;\n\t\t\t\t\n\t\t\t\t//Append the rest of the result rectangles to the output collection\n\t\t\t\tList_for_each_skip(clip_list, rect, Rect*, 1) {\n                    \n                    new_rect = Rect_new(rect->top, rect->left, rect->bottom, rect->right);\n                    \n                    if(!new_rect) {\n\t\t\t\t\t    \n\t\t\t\t\t\tList_delete(clip_list, Rect_deleter);\n\t\t\t\t\t\tList_delete(out_rects, Rect_deleter);\t\n                        return;\n\t\t\t\t\t}\n                    \n                    if(!List_add(out_rects, (void*)new_rect)){\n\t\t\t\t\t\t\n\t\t\t\t\t\tfree((void*)new_rect);\n\t\t\t\t\t\tList_delete(clip_list, Rect_deleter);\n\t\t\t\t\t\tList_delete(out_rects, Rect_deleter);\t\n                        return;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//Free the space that was used for the split \n\t\t\t\tList_delete(clip_list, Rect_deleter);\n\t\t\t\t\n\t\t\t\t//Restart the list \n\t\t\t\tList_rewind(out_rects);\n\t\t\t} \n\t\t}\n\t\t\n//\t\tcons_prints(\"Moving on to next splitter\\n\");\n\t}\n\t\n//\tcons_prints(\"Drawing sub-rects of window #\");\n//    cons_printDecimal(win->handle);\n//\tcons_putc('\\n');\n    List_for_each(out_rects, out_rect, Rect*) {\n\n#ifdef RECT_TEST    \n        //printf(\"%u, %u, %u, %u\\n\", out_rects[k].top, out_rects[k].left, out_rects[k].bottom, out_rects[k].right);\n#endif //RECT_TEST\n        \n\t\t\n/*\n\t\tcons_prints(\"    (\");\n\t\tcons_printDecimal(out_rect->top);\n\t\tcons_prints(\", \");\n\t\tcons_printDecimal(out_rect->left);\n\t\tcons_prints(\", \");\n\t\tcons_printDecimal(out_rect->bottom);\n\t\tcons_prints(\", \");\n\t\tcons_printDecimal(out_rect->right);\n\t\tcons_prints(\")\\n\");               \n*/  \n      drawBmpRect(win, out_rect);     \n    }\n\t\n//\tscans(10, inbuf);\n\t\n\tList_delete(out_rects, Rect_deleter);\n}\n\nwindow* newWindow(unsigned int width, unsigned int height, unsigned char flags, unsigned int pid) {\n    \n\tstatic int next_handle = 1; \n    window *new_window, *temp_window;\n    unsigned int i, bufsz;\n    \t\n    if(!(new_window = (window*)malloc(sizeof(window)))) {\n        \n        return 0;\n    }\n        \n    new_window->active = 1;\n\tnew_window->pid = pid;\n    new_window->flags = flags;\n    new_window->x = 0;\n    new_window->y = 0;\n    new_window->w = width;\n    new_window->h = height;\n    new_window->title = (unsigned char*)0;\n    new_window->frame_needs_redraw = 1;\n    \n    //Create a drawing context for the new window\n    if(!(new_window->context = newBitmap(new_window->w, new_window->h))) {\n        \n        free((void*)new_window);\n        return (window*)0;\n    } \n    \n    bufsz = new_window->w * new_window->h;\n    \n    //Clear new window to white\n    for(i = 0; i < bufsz; i++)\n        new_window->context->data[i] = RGB(255, 255 ,255);\n        \n    new_window->handle = next_handle++;\n\t\n\t//De-activate the old active window\n\tif(temp_window = (window*)List_get_at(window_list, window_list->count - 1)) {\n\t\t\n\t    temp_window->active = 0;\n\t} \n\t\n\tif(!List_add(window_list, (void*)new_window)){\n\t\t\n\t\tfreeBitmap(new_window->context);\n\t    free((void*)new_window);\n\t\t\n\t\t//re-activate the old active window\n\t\tif(temp_window)\n\t\t    temp_window->active = 1;\n        \n\t\treturn (window*)0;\t\n\t}\n    \n\t//Give the new window its initial decoration\n\tif(!(new_window->flags & WIN_UNDECORATED))\n\t    drawFrame(new_window);\n\t\n\tdrawWindow(new_window, 0);\n\t\n\t//Update the titlebar on the old active window \n\tif(temp_window)\n\t\tdrawTitlebar(temp_window, 0);\n\t\n    //cmd_printDecimal(new_window->handle);\n    //pchar('\\n');\n    return new_window;\n}\n\nunsigned int newWindowHandle(unsigned int width, unsigned int height, unsigned char flags, unsigned int pid) {\n\t\n\twindow* ret_window = newWindow(width, height, flags, pid);\n\t\n\tif(ret_window)\n\t    return ret_window->handle;\n\t\n\treturn 0;\n}\n\nwindow* getWindowByHandle(unsigned int handle) {\n    \n\twindow* out_window;\n\t    \n    List_for_each(window_list, out_window, window*) {\n        \n\t\tif(out_window->handle == handle)\n\t\t    return out_window;\n    }\n    \n    return (window*)0;\n}\n\nvoid showModes(void) {\n\n\n    unsigned short mode_count;\n    unsigned short i;\n    screen_mode* mode;\n\n    prints(\"Enumerating modes...\");\n    mode_count = enumerateModes();\n    prints(\"done\\n\");\n\n    prints(\"\\nAvailible modes:\\n\");\n    for(i = 1; i <= mode_count; i++) {\n\n        mode = getModeDetails(i);\n        prints(\"    \");\n        printDecimal((unsigned int)i);\n        prints(\") \");\n        printDecimal((unsigned int)mode->width);\n        pchar('x');\n        printDecimal((unsigned int)mode->height);\n        prints(\", \");\n        printDecimal((unsigned int)mode->depth);\n        prints(\"bpp\");\n\n        if(mode->is_linear)\n            prints(\" linear\");\n\n        pchar('\\n');\n    }\n}\n\nbitmap* getWindowContext(unsigned int handle) {\n    \n    window* dest_window = getWindowByHandle(handle);\n    \n    if(!dest_window) {\n     \n         //prints(\"[WYG] Couldn't find the window to get its context\\n\");   \n        return (bitmap*)0;\n    }\n        \n    return dest_window->context;\n}\n\n//Redraws every window intersected by window_bounds\nvoid updateOverlapped(Rect* window_bounds, window* avoid_window) {\n    \n    int i = 0;\n    Rect comp_rect, draw_rect; \n    window* cur_window;\n\t\n    //prints(\"[WYG] Looking for previously overlapped windows\\n\");\n        \n    for(i = 0; i < window_list->count; i++) {\n\n        cur_window = (window*)List_get_at(window_list, i);\n        \n\tif(!cur_window || cur_window == avoid_window)\n\t    continue;\n\t\t\n        comp_rect.top = cur_window->y;\n        comp_rect.left = cur_window->x;\n        comp_rect.bottom = comp_rect.top + cur_window->h - 1;\n        comp_rect.right = comp_rect.left + cur_window->w - 1;\n        \n        if((cur_window->flags & WIN_VISIBLE) && \n\t\t   window_bounds->left <= comp_rect.right &&\n           window_bounds->right >= comp_rect.left &&\n           window_bounds->top <= comp_rect.bottom && \n           window_bounds->bottom >= comp_rect.top) {\n            \n            if(window_bounds->top < comp_rect.top)\n                draw_rect.top = comp_rect.top; \n            else \n                draw_rect.top = window_bounds->top;\n                \n            if(window_bounds->left < comp_rect.left)\n                draw_rect.left = comp_rect.left; \n            else \n                draw_rect.left = window_bounds->left;\n                \n            if(window_bounds->bottom > comp_rect.bottom)\n                draw_rect.bottom = comp_rect.bottom; \n            else \n                draw_rect.bottom = window_bounds->bottom;\n                \n            if(window_bounds->right > comp_rect.right)\n                draw_rect.right = comp_rect.right; \n            else \n                draw_rect.right = window_bounds->right;\n            \n            cur_window->context->top = draw_rect.top - cur_window->y;\n            cur_window->context->left = draw_rect.left - cur_window->x;       \n            cur_window->context->bottom = draw_rect.bottom - cur_window->y;\n            cur_window->context->right = draw_rect.right - cur_window->x;        \n            drawWindow(cur_window, 1);\n        }\n    }\n}\n\nvoid markWindowVisible(window* dest_window, unsigned char is_visible);\n\nvoid changeWindowPosition(window* dest_window, unsigned short new_x, unsigned short new_y) {\n    \n    Rect overlap_rect;\n            \n    //If a window is moved, we must ensure that it is the active window \n\tmarkWindowVisible(dest_window, 1);\n\traiseWindow(dest_window);\n    \n    //Create a rectangle covering the old location for later intersection\n    overlap_rect.top = dest_window->y;\n    overlap_rect.left = dest_window->x;\n    overlap_rect.bottom = overlap_rect.top + dest_window->h - 1;\n    overlap_rect.right = overlap_rect.left + dest_window->w - 1;\n        \n    dest_window->x = new_x;\n    dest_window->y = new_y;\n    \n    //Need to update the screen if we're visible    \n    if(dest_window->flags & WIN_VISIBLE) {\n        \n\t\t//Should update this so that we don't redraw stuff that's going to\n\t\t//be under the window's new location because we're going to draw\n\t\t//over that when we draw the window at the new location anyhow     \n        updateOverlapped(&overlap_rect, dest_window); //Redraw all of the siblings that this window was covering up\n        \n        //Redraw the window at its new location\n        dest_window->frame_needs_redraw = 1;\n        drawWindow(dest_window, 0);\n    } \n        \n    return;\n}\n\nvoid moveHandle(unsigned int handle, unsigned short new_x, unsigned short new_y) {\n    \n    window* dest_window = getWindowByHandle(handle);\n    \n    if(!dest_window) {\n     \n         //prints(\"[WYG] Couldn't find window to mark it visible\\n\");   \n        return;\n    }\n       \n    changeWindowPosition(dest_window, new_x, new_y);\n}\n\nvoid installWindow(unsigned int child_handle, unsigned int parent_handle) {\n    \n\t//Right now, we removed all of the parent-child relationships in the window object,\n\t//so this doesn't really do anything. In the future, we should probably do \n\t//something with it, though\n\t\n\t/*\n    window* child_window = getWindowByHandle(child_handle);\n    window* parent_window = getWindowByHandle(parent_handle);\n    window* sibling_window;\n    \n    if(!child_window || !parent_window) {\n     \n         //prints(\"[WYG] Couldn't find the parent or child window to perform window install\\n\");   \n        return;\n    }\n    \n    child_window->parent = parent_window;    \n    sibling_window = parent_window->first_child;\n    \n    if(!sibling_window) {\n        \n        parent_window->first_child = child_window;\n        return;\n    }\n    \n    while(sibling_window->next_sibling)\n        sibling_window = sibling_window->next_sibling;\n        \n    sibling_window->next_sibling = child_window;\n    \n    return;\n\t*/   \n}\n\nvoid markWindowVisible(window* dest_window, unsigned char is_visible) {\n    \n    unsigned char was_visible;\n    Rect overlap_rect;\n    \n    was_visible = dest_window->flags & WIN_VISIBLE;\n    \n\tif(!!was_visible && !!is_visible)\n\t    return;\n\n    if(is_visible) {\n               \n        dest_window->flags |= WIN_VISIBLE;\n\t\tdrawWindow(dest_window, 0);\n    } else {\n        \n        dest_window->flags &= ~((unsigned char)WIN_VISIBLE);\n\t\toverlap_rect.top = dest_window->y;\n        overlap_rect.left = dest_window->x;\n        overlap_rect.bottom = overlap_rect.top + dest_window->h - 1;\n        overlap_rect.right = overlap_rect.left + dest_window->w - 1;\n        updateOverlapped(&overlap_rect, dest_window); //Redraw all of the siblings that this window was covering up\n    }\n    \t\n    return;\n}\n\nvoid markHandleVisible(unsigned int handle, unsigned char is_visible) {\n    \n    window* dest_window = getWindowByHandle(handle);\n    \n    if(!dest_window) {\n     \n         //prints(\"[WYG] Couldn't find window to mark it visible\\n\");   \n        return;\n    }\n    \n    markWindowVisible(dest_window, is_visible);\n}\n\nvoid markWindowDirty(unsigned int handle) {\n    \n    window* dest_window = getWindowByHandle(handle);\n    \n    if(!dest_window) {\n     \n         //prints(\"[WYG] Couldn't find window to mark it dirty\\n\");   \n        return;\n    }\n        \n    dest_window->needs_redraw = 1;\n    \n    return;\n}\n\nvoid setWindowTitle(unsigned int handle, unsigned char* newstr) {\n    \n    window* dest_window = getWindowByHandle(handle);\n    \n    if(!dest_window) {\n     \n         //prints(\"[WYG] Couldn't find window to mark it dirty\\n\");   \n        return;\n    }\n    \n    if(dest_window->title)\n        free(dest_window->title);\n        \n    dest_window->title = newstr;\n    \n    drawTitlebar(dest_window, 1);\n}\n\nvoid bmpDrawPanel(bitmap* bmp, int x, int y, int width, int height, unsigned int color, int border_width, int invert) {\n\n    unsigned char r = RVAL(color);\n    unsigned char g = GVAL(color);\n    unsigned char b = BVAL(color);\n    unsigned int light_color = RGB(r > 155 ? 255 : r + 100, g > 155 ? 255 : g + 100, b > 155 ? 255 : b + 100);\n    unsigned int shade_color = RGB(r < 100 ? 0 : r - 100, g < 100 ? 0 : g - 100, b < 100 ? 0 : b - 100);\n    unsigned int temp;\n    int i;\n\n    if(invert) {\n\n        temp = shade_color;\n        shade_color = light_color;\n        light_color = temp;\n    }\n\n    for(i = 0; i < border_width; i++) {\n\n        //Top edge\n        bmpDrawHLine(bmp, x+i, y+i, width-(2*i), light_color);\n\n        //Left edge\n        bmpDrawVLine(bmp, x+i, y+i+1, height-((i+1)*2), light_color);\n\n        //Bottom edge\n        bmpDrawHLine(bmp, x+i, (y+height)-(i+1), width-(2*i), shade_color);\n\n        //Right edge\n        bmpDrawVLine(bmp, x+width-i-1, y+i+1, height-((i+1)*2), shade_color);\n    }\n}\n\nvoid drawTitlebar(window* cur_window, int do_refresh) {\n    \n    unsigned char* s;    \n    unsigned int tb_color, text_color;\n    Rect old_ctx_rect;\n    \n\tif(cur_window->flags & WIN_UNDECORATED)\n\t    return;\n\t    \n    //Titlebar\n    if(cur_window->active)\n        tb_color = RGB(182, 0, 0);\n    else \n        tb_color = RGB(238, 203, 137);\n    \n    bmpFillRect(cur_window->context, 4, 4, cur_window->w - 28, 20, tb_color);\n        \n     //Window title\n    if(cur_window->title) {\n        \n         //prints(cur_window->title);\n        \n        int base_x, base_y, off_x, titlebar_width;\n        \n        s = cur_window->title;\n        base_x = 7;\n        base_y = 9;\n        off_x = 0;\n        titlebar_width = cur_window->w - 28;\n        \n        if(cur_window->active)\n            text_color = RGB(255, 255, 255);\n        else\n            text_color = RGB(138, 103, 37);\n        \n        while(*s) {\n            bmpDrawCharacter(cur_window->context, *(s++), base_x + off_x, base_y, text_color);\n            off_x += 8;\n            \n            //Truncate the text if it's wider than the titlebar\n            if(off_x >= titlebar_width)\n                break;\n        }\n    }\n    \n\tif(do_refresh) {\n\t\n\t\told_ctx_rect.top = cur_window->context->top;\n\t\told_ctx_rect.left = cur_window->context->left;\n\t\told_ctx_rect.bottom = cur_window->context->bottom;\n\t\told_ctx_rect.right = cur_window->context->right;\n\t\t\n\t\tcur_window->context->top = 4;\n\t\tcur_window->context->left = 4;\n\t\tcur_window->context->bottom = 23;\n\t\tcur_window->context->right = cur_window->context->right - 25;\n\t\t\n\t\tdrawWindow(cur_window, 1);\n\t\t\n\t\tcur_window->context->top = old_ctx_rect.top;\n\t\tcur_window->context->left = old_ctx_rect.left;\n\t\tcur_window->context->bottom = old_ctx_rect.bottom;\n\t\tcur_window->context->right = old_ctx_rect.right;\n\t}\n}\n\nvoid drawFrame(window* cur_window) {\n    \n    int i;\n    \n    \n     //prints(\"[WYG] Drawing frame for window \");\n      //printDecimal(cur_window->handle);\n     //pchar('\\n');\n    \n    //Outer border\n    bmpDrawPanel(cur_window->context, 0, 0, cur_window->w, cur_window->h, RGB(238, 203, 137), 1, 0);\n    \n    //Title border\n    bmpDrawPanel(cur_window->context, 3, 3, cur_window->w - 6, 22, RGB(238, 203, 137), 1, 1);\n    \n    //Body border\n    bmpDrawPanel(cur_window->context, 3, 27, cur_window->w - 6, cur_window->h - 30, RGB(238, 203, 137), 1, 1);\n    \n    //Left frame\n    bmpFillRect(cur_window->context, 1, 1, 2, cur_window->h - 2, RGB(238, 203, 137)); \n    \n    //Right frame\n    bmpFillRect(cur_window->context, cur_window->w - 3, 1, 2, cur_window->h - 2, RGB(238, 203, 137)); \n    \n    //Top frame\n    bmpFillRect(cur_window->context, 3, 1, cur_window->w - 6, 2, RGB(238, 203, 137)); \n    \n    //Mid frame\n    bmpFillRect(cur_window->context, 3, 25, cur_window->w - 6, 2, RGB(238, 203, 137)); \n    \n    //Bottom frame\n    bmpFillRect(cur_window->context, 3, cur_window->h - 3, cur_window->w - 6, 2, RGB(238, 203, 137)); \n        \n    //Button\n    bmpDrawPanel(cur_window->context, cur_window->w - 24, 4, 20, 20, RGB(238, 203, 137), 1, 0);\n    bmpFillRect(cur_window->context, cur_window->w - 23, 5, 18, 18, RGB(238, 203, 137)); \n    \n    drawTitlebar(cur_window, 0);\n    \n    cur_window->frame_needs_redraw = 0;\n}\n\nList* getOverlappingWindows(int lowest_z_level, Rect* baserect) {\n\n    List* rect_list = List_new();\n\t\n\tif(!rect_list) {\n\t\t\n\t\treturn (List*)0;\n\t}\n\t    \n\tRect* new_rect;\n\twindow* cur_window;\n    \n\tList_for_each_skip(window_list, cur_window, window*, lowest_z_level) {\n\t\t\n\t\t//Count the window only if it overlaps\n\t\tif(cur_window->x <= baserect->right &&\n\t\t   (cur_window->x + cur_window->context->width - 1) >= baserect->left &&\n\t\t   cur_window->y <= baserect->bottom && \n\t\t   (cur_window->y + cur_window->context->height - 1) >= baserect->top) {\n\t\t\n\t\t        if(!(new_rect = Rect_new(cur_window->y, cur_window->x, (cur_window->y + cur_window->context->height - 1), (cur_window->x + cur_window->context->width - 1)))) {\n\t\t\t\t\t\n\t\t\t\t\tList_delete(rect_list, Rect_deleter);\n\t\t\t\t\treturn (List*)0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!List_add(rect_list, new_rect)) {\n\t\t\t\t\t\n\t\t\t\t\tfree((void*)new_rect);\n\t\t\t\t\tList_delete(rect_list, Rect_deleter);\n\t\t\t\t\treturn (List*)0;\n\t\t\t\t}\n\t\t}\n\t}\n        \n    return rect_list;\n}\n\nvoid drawWindow(window* cur_window, unsigned char use_current_blit) {\n     \n    unsigned int rect_count;\n    List* splitrect_list;\n    Rect winrect;\n    int i;\n    \n     //prints(\"[WYG] Drawing window \");\n      //printDecimal(cur_window->handle);\n     //pchar('\\n');\n    \n    if(cur_window->flags & WIN_VISIBLE) {\n        \n        cur_window->needs_redraw = 0;\n        \n        //Start by drawing this window\n        //prints(\"[WYG] Drawing window frame\\n\");\n        \n        //Create a rectangle for the window to be drawn\n        if(use_current_blit) {\n            \n            //prints(\"[WYG] Setting base rectangle using winrect\\n\");\n            //Convert the current blit window to desktop space\n            winrect.top = cur_window->y + cur_window->context->top;\n            winrect.left = cur_window->x + cur_window->context->left;\n            winrect.bottom = cur_window->y + cur_window->context->bottom;\n            winrect.right = cur_window->x + cur_window->context->right;\n        } else {\n                \n            //prints(\"[WYG] Setting base rectangle using whole ctx\\n\");\n            winrect.top = cur_window->y;\n            winrect.left = cur_window->x;\n            winrect.bottom = cur_window->y + cur_window->context->height - 1;\n            winrect.right = cur_window->x + cur_window->context->width - 1;\n        }\n        \n        \n\t\tif(!(splitrect_list = getOverlappingWindows(List_get_index(window_list, (void*)cur_window) + 1, &winrect))) { //build the rects\n\t\t\n\t\t\treturn;\n\t\t}        \n        \t\t\n        drawOccluded(cur_window, &winrect, splitrect_list);   \n        //prints(\"[WYG] Finished doing occluded draw\\n\");    \n        \n        //getch();\n        \n        List_delete(splitrect_list, Rect_deleter);       \n    }\n    \n     //prints(\"[WYG] Finished drawing window \");\n      //printDecimal(cur_window->handle);\n     //pchar('\\n');\n    \n    return;\n}\n\nvoid drawHandle(unsigned int handle) {\n    \n    window* dest_window = getWindowByHandle(handle);\n    \n    if(!dest_window) {\n     \n         //prints(\"[WYG] Couldn't find the window to be raised\\n\");   \n        return;\n    }\n    \n    //Draw the window, assume we want to use the blit window set up by the client   \n    drawWindow(dest_window, 1);\n}\n\nvoid raiseWindow(window* dest_window) {\n    \n    window* old_active;\n            \n    //Can't raise the root window, mouse window, a null window pointer or if there's nothing but the root and\n    //mouse in the window list\n    if(dest_window == root_window || dest_window == mouse_window || !dest_window || window_list->count == 2)\n        return;\n        \n    //Get the previously active window \n    old_active = (window*)List_get_at(window_list, window_list->count - 2);\n    \n    //If we were already active we don't need to do anything else \n    if(old_active == dest_window)\n        return;\n\n    //extract the current window from its position in the list and\n    //re-insert it at the end, making sure to pop and restore the\n    //mouse window as well to keep it always on top\n    if(!List_pop(window_list, (void*)mouse_window))\n        return;\n\n    if(!List_pop(window_list, (void*)dest_window))\n        return;\n\n    if(!List_add(window_list, (void*)dest_window))\n        return;\n\n    if(!List_add(window_list, (void*)mouse_window))\n        return;\n\t\t\n    //Update the titlebar on the old and new active windows \n    old_active->active = 0;\n    dest_window->active = 1;\n    drawTitlebar(old_active, 1);\n    drawTitlebar(dest_window, 0);\n\t\n    //If the window isn't visible, it will need to be in order to be\n    //raised, otherwise we just redraw (would be more efficient in\n    //the future to just redraw those portions that were occluded\n    //prior to raising)\n    if(!(dest_window->flags &= WIN_VISIBLE))\n        markWindowVisible(dest_window, 1);\n    else\n        drawWindow(dest_window, 0);\n}\n\nvoid raiseHandle(unsigned int handle) {\n\n    //Can't raise the root or mouse windows\n    if(handle == 1 || handle == 2)\n        return;\n    \n    window* dest_window = getWindowByHandle(handle);\n\n    if(!dest_window) {\n     \n         //prints(\"[WYG] Couldn't find the window to be raised\\n\");   \n        return;\n    }\n    \n    raiseWindow(dest_window);\n}\n\nvoid window_deleter(void* item) {\n\t\n\twindow* win = (window*)item;\n\t\n\t//Free the context\n    freeBitmap((void*)win->context);\n\n#ifndef HARNESS_TEST    \n    //Free the title (if we ever decide to error on unsuccessful frees, this could be an issue for static or undefined titles)\n    if(win->title)\n\tfree((void*)win->title);\n#endif //HARNESS_TEST\n    \n    //And finally free ourself \n    free((void*)win);\n}\n\nvoid destroy(window* dest_window) {\n\n    window *cur_child, *next, *active_window;\n    int i;\n            \n    //Start by hiding the window \n    markWindowVisible(dest_window, 0);\n\tList_remove(window_list, (void*)dest_window, window_deleter);\n    active_window = (window*)List_get_at(window_list, window_list->count - 1);\n\t\n\tif(!active_window)\n\t    return;\n\t\t\n\tif(!active_window->active) {\n\t\t\n\t\tactive_window->active;\n\t\tdrawTitlebar(active_window, 1);\n\t}\n}\n\nvoid destroyHandle(unsigned int handle) {\n    \n    window* dest_window = getWindowByHandle(handle);\n    \n    if(!dest_window) \n        return;\n        \n    destroy(dest_window);\n}\n\nunsigned int cons_x, cons_y;\nunsigned int cons_max_c, cons_max_l;\n\n/*\nvoid cons_init() {\n\t\n\tcons_x = 0;\n\t\n\tif(inited)\n\t\tcons_y = 1;\n\telse \n\t    cons_y = 0;\n\t\t\n\tcons_max_c = root_window->w / 8;\n\tcons_max_l = (root_window->h / 12) - cons_y; \n}\n\nvoid cons_putc(char c) {\n\t\n\tif(cons_y >= cons_max_l)\n\t    return;\n\t\n\tif(c == '\\n') {\n\t    \n\t\tcons_x = 0;\n\t\tcons_y++;\n\t    return;\n\t}\n\t\n\tdrawCharacter(c, cons_x * 8, cons_y * 12, RGB(0, 0, 0)); \n\t\n\tcons_x++;\n\t\n\tif(cons_x >= cons_max_c) {\n\t\tcons_x = 0;\n\t\tcons_y++;\n\t}\n}\n\nvoid cons_prints(char* s) {\n\t\n\twhile(*s) \n\t    cons_putc(*(s++));\n}\n\nvoid cons_printDecimal(unsigned int dword) {\n\n    unsigned char digit[12];\n    int i, j;\n\n    i = 0;\n    while(1) {\n\n        if(!dword) {\n\n            if(i == 0)\n                digit[i++] = 0;\n\n            break;\n        }\n\n        digit[i++] = dword % 10;\n        dword /= 10;\n    }\n\n    for(j = i - 1; j >= 0; j--)\n        cons_putc(digit[j] + '0');\n}\n\nvoid cons_printHexByte(unsigned char byte) {\n\n    cons_putc(digitToHex((byte & 0xF0)>>4));\n    cons_putc(digitToHex(byte & 0xF));\n}\n\n\nvoid cons_printHexWord(unsigned short wd) {\n\n    cons_printHexByte((unsigned char)((wd & 0xFF00)>>8));\n    cons_printHexByte((unsigned char)(wd & 0xFF));\n}\n\n\nvoid cons_printHexDword(unsigned int dword) {\n\n    cons_printHexWord((unsigned short)((dword & 0xFFFF0000)>>16));\n    cons_printHexWord((unsigned short)(dword & 0xFFFF));\n}\n*/\n\nvoid window_printer(void* value) {\n\t\n\n\twindow* win = (window*)value;\n\nEM_ASM_({\t\n\tconsole.log(\"    window \" +\n\t            $0            +\n\t            \" @ 0x\"       +\n\t            $1\n        );\n}, win->handle, (unsigned int)win);\n\n}\n\nvoid exceptionHandler(void) {\n\n/*\t\n\tcons_init();\n\tcons_prints(\"Operating system raised an exception\\n\");\n\tcons_prints(\"There were \");\n\tcons_printDecimal(window_list->count);\n\tcons_prints(\" windows installed:\\n\");\n\tList_print(window_list, window_printer);\n*/\n\twhile(1);\n}\n\nunsigned char mouse_down = 0;\nwindow* drag_window = (window*)0;\nint drag_x, drag_y;\n\nvoid putMouse(int x, int y, unsigned char buttons) {\n\n    int i;\n    window* cur_window;\n\n    changeWindowPosition(mouse_window, x, y);\n    \n    if(buttons) {\n\n        if(!mouse_down) {\n\n            mouse_down = 1;\n        \n            for(i = window_list->count - 2; i > 0; i--) {\n\n                cur_window = (window*)List_get_at(window_list, i);   \n\n                if(!cur_window || cur_window == root_window || cur_window == mouse_window) \n                    continue;\n\n                if(x >= cur_window->x &&\n                   x < cur_window->x + cur_window->w &&\n                   y >= cur_window->y &&\n                   y < cur_window->y + cur_window->h) {\n\n                    drag_x = x - cur_window->x;\n                    drag_y = y - cur_window->y;\n                    drag_window = cur_window;\n                    break;\n                }\n            }\n        }\n    } else {\n       \n        mouse_down = 0;\n        drag_window = (window*)0;\n    }\n\n    if(mouse_down && drag_window) {\n   \n         changeWindowPosition(drag_window, x - drag_x, y - drag_y);\n    }\n}\n\nvoid moveMouse(short x_off, short y_off) {\n\n    mouse_x += x_off;\n    mouse_y += y_off;\n\n    if(mouse_x < 0)\n        mouse_x = 0;\n\n    if(mouse_x > root_window->w - 20)\n        mouse_x = root_window->w - 20;\n\n    if(mouse_y < 0)\n        mouse_y = 0;\n    \n    if(mouse_y > root_window->h - 20)\n        mouse_y = root_window->h - 20;\n\n    changeWindowPosition(mouse_window, mouse_x, mouse_y);\n}\n\n#ifdef HARNESS_TEST\nvoid WYG_main(void) {\n#else \nvoid main(void) {\n#endif //HARNESS_TEST\n\n    unsigned int parent_pid;\n    screen_mode* mode;\n    unsigned short num;\n    unsigned int current_handle;\n    int i;\n    window* temp_window;\n    unsigned int src_pid;\n    unsigned char* instr;\n    unsigned int strlen;\n\n#ifndef HARNESS_TEST\n\n    //Get the 'here's my pid' message from init\n    getMessage(&temp_msg);\n    parent_pid = temp_msg.source;\n    //prints(\"[WYG] Starting WYG GUI services.\\n\");\n\n    //First thing, register as a WYG service with the registrar\n    postMessage(REGISTRAR_PID, REG_REGISTER, SVC_WYG);\n    getMessage(&temp_msg);\n\n    if(!temp_msg.payload) {\n\n        //prints(\"\\n[WYG] failed to register WYG service.\\n\");\n        postMessage(REGISTRAR_PID, REG_DEREGISTER, SVC_WYG);\n        postMessage(parent_pid, 0, 0); //Tell the parent we're done registering\n        terminate();\n    }\n\n    if(!initKey()) {\n        \n        postMessage(REGISTRAR_PID, REG_DEREGISTER, SVC_WYG);\n        postMessage(parent_pid, 0, 0); //Tell the parent we're done registering\n        terminate();\n    }\n\n    if(!initMouse()) {\n        \n        //Don't need to terminate, but do need to display a warning to the user\n    }\n\n#endif //HARNESS_TEST\n\n    if(!initGfx()) {\n        \n        //prints(\"\\n[WYG] failed to get the GFX server.\\n\");\n        postMessage(REGISTRAR_PID, REG_DEREGISTER, SVC_WYG);\n        postMessage(parent_pid, 0, 0); //Tell the parent we're done registering\n        terminate();\n    }\n\n#ifdef HARNESS_TEST\n\n    num = 1;\n\n#else\n\n    //Prompt user for a screen mode\n    showModes();\n    prints(\"mode: \");\n    scans(10, inbuf);\n    num = inbuf[0] > '9' ? inbuf[0] - 'A' + 10 : inbuf[0] - '0';\n\n#endif //HARNESS_TEST\n\n    if(!setScreenMode(num)) {\n\n        //prints(\"[WYG] Could not set screen mode.\\n\");\n        postMessage(REGISTRAR_PID, REG_DEREGISTER, SVC_WYG);\n        postMessage(parent_pid, 0, 0); //Tell the parent we're done registering\n        terminate();\n    }\n\n//    installExceptionHandler((void*)exceptionHandler);\n\n    if(num) {\n\n        mode = getModeDetails(num);\n    } else {\n\n        //prints(\"[WYG] Staying in text mode.\\n\");\n        postMessage(REGISTRAR_PID, REG_DEREGISTER, SVC_WYG);\n        postMessage(parent_pid, 0, 0); //Tell the parent we're done registering\n        terminate();\n    }\n    \n\t//cmd_init(mode->width, mode->height);\n\t\n    if(!(window_list = List_new())) {\n        \n        prints(\"[WYG] Couldn't allocate window list.\\n\");\n        postMessage(REGISTRAR_PID, REG_DEREGISTER, SVC_WYG);\n        postMessage(parent_pid, 0, 0); //Tell the parent we're done registering\n        terminate();\n    }\n    \n    //Init the root window (aka the desktop)\n    root_window = newWindow(mode->width, mode->height, WIN_UNDECORATED | WIN_FIXEDSIZE | WIN_VISIBLE, 0);\n\t\n    //Create a drawing context for the root window\n    if(!root_window) {\n        \n        //prints(\"[WYG] Could not allocate a context for the root window.\\n\");\n        //Need to do a list free here for the window_list\n        postMessage(REGISTRAR_PID, REG_DEREGISTER, SVC_WYG);\n        postMessage(parent_pid, 0, 0); //Tell the parent we're done registering\n        terminate();\n    } \n\n    //Set up the initial mouse position\n    mouse_x = root_window->w / 2 - 1;\n    mouse_y = root_window->h / 2 - 1;\n\n    //Create the mouse window\n    mouse_window = newWindow(20, 20, WIN_UNDECORATED | WIN_FIXEDSIZE | WIN_VISIBLE, 0);\n\n    //Fail if the mouse couldn't be created\n    if(!mouse_window) {\n        \n        postMessage(REGISTRAR_PID, REG_DEREGISTER, SVC_WYG);\n        postMessage(parent_pid, 0, 0);\n        terminate();\n    }\n\n    changeWindowPosition(mouse_window, mouse_x, mouse_y);\n\n    postMessage(parent_pid, 0, 1); //Tell the parent we're done registering\n\n    //Paint the initial scene\n    for(i = 0; i < root_window->w * root_window->h; i++)\n        root_window->context->data[i] = RGB(11, 162, 193);\n    \n    drawWindow(root_window, 0);\n    drawWindow(mouse_window, 0);\n\t        \n    //Start debug console\n    //init(root_window.w, 48);\n\n#ifdef HARNESS_TEST\n\n    //enter the testing code\n    testMain();\n    endGfx();\n    return;\n\n#else \n    \n\tcons_init();\n\t\n    //Now we can start the main message loop \n\t//cmd_prints(\"Wyg started\");\n    while(1) {\n\n        //prints(\"[WYG] Waiting for message...\");\n        getMessage(&temp_msg);\n        //prints(\"got message \");\n         //printDecimal(temp_msg.command);\n        ////pchar('\\n');\n\n        src_pid = temp_msg.source;\n\n        switch(temp_msg.command) {\n\n            case WYG_CREATE_WINDOW:\n\t\t\t    //cmd_prints(\"Request to create a new window\");\n                postMessage(src_pid, WYG_CREATE_WINDOW, (unsigned int)newWindowHandle((temp_msg.payload & 0xFFF00000) >> 20, (temp_msg.payload & 0xFFF00) >> 8, temp_msg.payload & 0xFF, src_pid));\n            break;\n            \n            case WYG_GET_CONTEXT:\n                postMessage(src_pid, WYG_GET_CONTEXT, (unsigned int)getWindowContext(temp_msg.payload));\n            break;\n            \n            case WYG_GET_DIMS:\n                temp_window = getWindowByHandle(temp_msg.payload);\n                postMessage(src_pid, WYG_GET_DIMS, (unsigned int)((((temp_window->w & 0xFFFF) << 16)) | (temp_window->h & 0xFFFF)));\n            break;\n            \n            case WYG_GET_LOCATION:\n                temp_window = getWindowByHandle(temp_msg.payload);\n                postMessage(src_pid, WYG_GET_LOCATION, (unsigned int)((((temp_window->x & 0xFFFF) << 16)) | (temp_window->y & 0xFFFF)));\n            break;\n            \n            case WYG_MOVE_WINDOW:\n                current_handle = temp_msg.payload;\n                getMessageFrom(&temp_msg, src_pid, WYG_POINT);\n                moveHandle(current_handle, (temp_msg.payload & 0xFFFF0000) >> 16, temp_msg.payload & 0xFFFF);\n            break;\n\n            case WYG_INSTALL_WINDOW:\n                current_handle = temp_msg.payload;\n                getMessageFrom(&temp_msg, src_pid, WYG_WHANDLE);\n                installWindow(current_handle, temp_msg.payload);\n            break;\n\n            case WYG_SHOW_WINDOW:\n                markHandleVisible(temp_msg.payload, 1);\n            break;\n            \n            case WYG_RAISE_WINDOW:\n                raiseHandle(temp_msg.payload);\n            break;\n\n            case WYG_REPAINT_WINDOW:\n                drawHandle(temp_msg.payload);\n                postMessage(src_pid, WYG_REPAINT_WINDOW, 1);\n            break;\n\n            case WYG_SET_TITLE:\n                current_handle = temp_msg.payload;\n                postMessage(src_pid, WYG_SET_TITLE, 1);\n                strlen = getStringLength(src_pid);\n                instr = (unsigned char*)malloc(strlen);\n                getString(src_pid, instr, strlen);\n                setWindowTitle(current_handle, instr);\n            break;\n            \n            case WYG_DESTROY:\n                destroyHandle(temp_msg.payload);\n                postMessage(src_pid, WYG_DESTROY, 1);\n            break;\n            \n            case WYG_GET_FRAME_DIMS:\n                postMessage(src_pid, WYG_GET_FRAME_DIMS, (FRAME_SIZE_TOP << 24) | (FRAME_SIZE_LEFT << 16) | (FRAME_SIZE_BOTTOM << 8) | (FRAME_SIZE_RIGHT));\n            break;\n\n            case MOUSE_SEND_UPDATE:\n                setColor(RGB(255, 0, 0));\n                displayString(0, 0, \"GOT A MOUSE EVENT!\");\n                while(1);\n            break;\n\n            default:\n            break;\n        }\n    }\n    \n#endif //HARNESS_TEST\n    \n}\n","#include \"../p5-redux/P5OSPPB/mods/include/gfx.h\"\n\ntypedef struct window {\n    unsigned char active;\n    unsigned char flags;\n    unsigned int handle;\n    unsigned int pid;\n    bitmap* context;\n    unsigned int w;\n    unsigned int h;\n    unsigned int x;\n    unsigned int y;\n    unsigned char needs_redraw;\n    unsigned char* title;\n    unsigned char frame_needs_redraw;\n} window;\n\nextern void moveMouse(short x_off, short y_off);\nextern window* getWindowByHandle(unsigned int handle);\nextern void moveHandle(unsigned int handle, unsigned short new_x, unsigned short new_y);\nextern void markHandleVisible(unsigned int handle, unsigned char is_visible);\nextern void drawHandle(unsigned int handle);\nextern void raiseHandle(unsigned int handle);\nextern void setWindowTitle(unsigned int handle, unsigned char* newstr);\nextern void destroyHandle(unsigned int handle);\nextern unsigned int newWindowHandle(unsigned int width, unsigned int height, unsigned char flags, unsigned int pid);\n\nunsigned int createWindow(unsigned short width, unsigned short height, unsigned char flags) {\n\n    return newWindowHandle((unsigned int)width, (unsigned int)height, (unsigned int)flags, 0);\n}\n\nunsigned int initWYG(void) {\n\n    return 1;\n}\n\nvoid updateMouse(short x_off, short y_off) {\n\n    moveMouse(x_off, y_off);\n}\n\nvoid getWindowDimensions(unsigned int handle, unsigned short *w, unsigned short *h) {\n\n    window* temp_window = getWindowByHandle(handle);\n    *w = (unsigned short)(temp_window->w & 0xFFFF);\n    *h = (unsigned short)(temp_window->h & 0xFFFF);\n}\n\nvoid moveWindow(unsigned int handle, unsigned short x, unsigned short y) {\n\n    moveHandle(handle, (unsigned int)x, (unsigned int)y);\n}\n\nvoid showWindow(unsigned int handle) {\n\n    markHandleVisible(handle, 1);\n}\n\nvoid repaintWindow(unsigned int handle) {\n  \n    drawHandle(handle);\n}\n\nvoid focus(unsigned int handle) {\n\n    raiseHandle(handle);\n}\n\nvoid setTitle(unsigned int handle, unsigned char* string) {\n\n    setWindowTitle(handle, string);\n}\n\nvoid getWindowLocation(unsigned int handle, unsigned short* x, unsigned short* y) {\n\n    window* temp_window = getWindowByHandle(handle);\n    *x = (unsigned short)(temp_window->x & 0xFFFF);\n    *y = (unsigned short)(temp_window->y & 0xFFFF);\n}\n\nvoid destroyWindow(unsigned int handle) {\n\n    destroyHandle(handle);\n}\n\nvoid getFrameDims(unsigned char* top, unsigned char* left, unsigned char* bottom, unsigned char* right) {\n\n    *top = 28;\n    *left = 4;\n    *bottom = 4;\n    *right = 4;\n}\n","#include <stdlib.h>\n#include \"list.h\"\n\nList* List_new(void) {\n    \n    List* ret_list = (List*)malloc(sizeof(List));\n    \n    if(!ret_list)\n        return ret_list;\n        \n    ret_list->root_item = (ListItem*)0;\n    ret_list->count = 0;\n\tList_rewind(ret_list);\n   \t\n    return ret_list;\n}\n\n//Deletes all elements of the list, and deletes the contained values\n//using the passed delete function\n//extern void cmd_prints(char* s);\nvoid List_delete(List* list, deleter del_func) {\n\t\n\tListItem* current_item = list->root_item;\n\tListItem* prev_item;\n\n\t//cmd_prints(\"Checking to see if root item exists\");\n\tif(current_item && list->count) {\n\t\t\n\t\t//Fast forward to the end of the list\n\t\t//cmd_prints(\"Going to end of list\");\n\t\twhile(current_item->next)\n\t\t    current_item = current_item->next;\n\t\t\t\n\t    //Delete in reverse order\n\t\t//cmd_prints(\"Starting deletion\");\n\t\twhile(current_item && list->count) {\n\t\t \n\t\t    //cmd_prints(\"Getting previous item\");\n\t\t    //Temporarily store the previous element so that we don't lose it\n\t\t    prev_item = current_item->prev;\n\n\t\t\t//cmd_prints(\"Deleting current item\");\n\t\t\t//Use the supplied deleter to delete the lite item's value \n\t\t\tdel_func(current_item->value);\n\t\t\t\n\t\t\t//cmd_prints(\"Freeing list item container\");\n\t\t\t//Finally, get rid of the current ListItem and move back down the list\n\t\t\tfree((void*)current_item);\n\t\t\t\n\t\t\t//cmd_prints(\"Rewinding by one\");\n\t\t\tcurrent_item = prev_item;    \t\n\n                        list->count--;\n\t\t}\n\t}\n\t\n\t//cmd_prints(\"Freeing entire list structure\");\n\t//Now that we've deleted all of the content, we can free the root object\n\tfree((void*)list);\n}\n\nvoid* List_pop(List* list, void* value) {\n\t\n\tListItem* cur_item = list->root_item;\n\tvoid* ret_val;\n    \n    if(!value || list->count == 0) \n        return (void*)0;\n        \n    while(cur_item && (cur_item->value != value))\n        cur_item = cur_item->next;\n        \n    if(!cur_item)\n        return (void*)0;\n    \n    if(cur_item == list->current_item) {\n        \n        if(cur_item->prev) {\n            \n            list->current_item = cur_item->prev; \n        } else if(cur_item->next) {\n            \n            list->current_item = cur_item->next;\n        } else {\n            \n            list->current_item = (ListItem*)0;\n            list->root_item = (ListItem*)0;\n        }\n    }\n    \n\n    \n    if(cur_item->prev)\n        cur_item->prev->next = cur_item->next;\n        \n    if(cur_item->next)\n        cur_item->next->prev = cur_item->prev;\n    \n    list->count--;\n\tret_val = cur_item->value;\n\tfree((void*)cur_item);\n\treturn ret_val;\n}\n\nvoid List_remove(List* list, void* value, deleter del_func) {\n    \n    void* popval = List_pop(list, value);\n\t\n\tif(popval)\n    \t    del_func(value);        \n}\n\nvoid List_rewind(List* list) {\n    \n    list->current_item = list->root_item;\n}\n\nint List_add(List* list, void* value) {\n    \n    ListItem* current_item;\n    ListItem* new_item = (ListItem*)malloc(sizeof(ListItem));\n    \n    if(!new_item)\n        return 0;    \n    \n    new_item->value = value;\n    new_item->next = (ListItem*)0;\n\tnew_item->prev = (ListItem*)0;\n        \n    if(!list->root_item) {\n        \n        list->root_item = new_item;\n        list->current_item = new_item;\n    } else {\n        \n        current_item = list->root_item;\n        \n        while(current_item->next)\n            current_item = current_item->next;\n            \n        new_item->prev = current_item;\n        current_item->next = new_item; \n    }\n    \n    list->count++;\n\t\n    return 1;\n}\n\nvoid* List_get_next(List* list) {\n    \n    void* ret_val;\n    \n    if(!list->current_item) \n        return (void*)0;\n    \n    ret_val = list->current_item->value;\n    \n    if(list->current_item)\n        list->current_item = list->current_item->next;\n        \n    return ret_val;\n}\n\nvoid List_seek_to(List* list, int index) {\n\t\n\tListItem* cur_item = list->root_item;\n    \n\tif(index >= list->count) {\n    \n\t    list->current_item = (ListItem*)0;\n\t\treturn;\n\t}  \n    \n\tif(index < 0) \n\t    index = 0;\n    \n    while(index) {\n\t\t\n        cur_item = cur_item->next;\n\t    index--;\n\t}\n    \n    list->current_item = cur_item;\n}\n\nvoid* List_get_at(List* list, int index) {\n    \n    ListItem* cur_item = list->root_item;\n    \n\tif(index >= list->count)\n        index = list->count - 1;  \n    \n\tif(index < 0) \n\t    index = 0;\n    \n    while(index) {\n\t\t\n        cur_item = cur_item->next;\n\t    index--;\n\t}\n    \n    return cur_item ? cur_item->value : (void*)0;\n}\n\n//Finds the first instance of the pointer value in the list, -1 if not found\nint List_get_index(List* list, void* value) {\n\t\n\tvoid* cmp_value;\n\tint i = 0;\n\t\n\tList_for_each(list, cmp_value, void*) {\n\t\t\n\t\tif(cmp_value == value)\n\t\t    break;\n\t\t\n\t\ti++;\n\t}\n\t\n\tif(i == list->count)\n\t    return -1;\n    else\n\t    return i;\n}\n\nint List_has_next(List* list) {\n    \n    return !!(list->current_item);\n}\n\nvoid List_print(List* list, printer print_func) {\n    \n    void* value;\n    \n    List_for_each(list, value, void*) {\n            \n        print_func(value);\n    }\n}\n","#include <stdlib.h>\n#include \"rect.h\"\n\n//Used to delete the elements of a list when those elements are \nvoid Rect_deleter(void* item) {\n\t\n\tfree(item);\n}\n\nRect* Rect_new(unsigned int top, unsigned int left, unsigned int bottom, unsigned int right) {\n    \n    Rect* rect = (Rect*)malloc(sizeof(Rect));\n    \t\n    if(!rect)\n        return rect;\n    \n    rect->top = top;\n    rect->left = left;\n    rect->bottom = bottom;\n    rect->right = right;\n\n    return rect;\n}\n","#include \"../p5-redux/P5OSPPB/mods/include/p5.h\"\n#include \"../p5-redux/P5OSPPB/mods/include/gfx.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <emscripten.h>\n#include \"../p5-redux/P5OSPPB/mods/vesa/font.h\" \n\nscreen_mode mode_details;\n\nunsigned int pen_x = 0;\nunsigned int pen_y = 0;\nunsigned int pen_color = 0;\n\nunsigned char initGfx() {    \n    \n    EM_ASM(\n        var screen;\n\n        if(screen = document.getElementById('screen_canvas'))\n            screen.parentElement.removeChild(screen);\n\n        screen = document.createElement('canvas');\n        screen.width = window.innerWidth;\n        screen.height = window.innerHeight;\n        screen.id = 'screen_canvas';\n        window.screen_ctx = screen.getContext('2d');\n        document.body.style.margin = '0px';\n        document.body.appendChild(screen);\n        screen.style.cursor = 'none';\n    );\n            \n    return 1;\n}\n\nvoid endGfx() {\n    \n    //Don't need to do anything\n}\n\n//Simply returns the number of modes supported\nunsigned char enumerateModes() {\n\n    return (unsigned char)(1);\n}\n\nscreen_mode* getModeDetails(unsigned short modenum) {\n\n    if(!modenum)\n        return (screen_mode*)0;\n\n    //Unpack the passed values\n    mode_details.width = EM_ASM_INT({return document.getElementById('screen_canvas').width;},0);\n    mode_details.height = EM_ASM_INT({return document.getElementById('screen_canvas').height;},0);\n\n    //The bit of math in here is representative of the fact that we support 8-bit\n    //16-bit, 24-bit or 32-bit color\n    mode_details.depth = 32;\n    mode_details.is_linear = 1;\n    mode_details.number = 0; //Only the server cares about this\n\n    return &mode_details;\n}\n\nunsigned char setScreenMode(unsigned short modenum) {\n    \n    //Later maybe we'll try to set the window size dynamically later\n    return 1;\n}\n\nvoid setColor(unsigned int color) {\n\n    pen_color = color;\n    \n    EM_ASM_({\n        window.screen_ctx.strokeStyle = 'rgb(' + $0 + ',' + $1 + ',' + $2 + ',0)';\n        window.screen_ctx.fillStyle = window.screen_ctx.strokeStyle;\n    }, RVAL(color), GVAL(color), BVAL(color));\n}\n\nvoid setCursor(unsigned short x, unsigned short y) {\n\n    pen_x = x;\n    pen_y = y;\n}\n\nvoid setPixel() {\n\n    EM_ASM_({\n       var data = window.screen_ctx.getImageData(0, 0, 800, 600);\n       var i = ($0 + $1 * 800) * 4;\n       data.data[i + 0] = $2;\n       data.data[i + 1] = $3;\n       data.data[i + 2] = $4;\n       data.data[i + 3] = 255;\n       window.screen_ctx.putImageData(data, 0, 0);\n    }, pen_x, pen_y, RVAL(pen_color), GVAL(pen_color), BVAL(pen_color)); \n}\n\nvoid drawHLine(unsigned short length) {\n\n    EM_ASM_({\n        window.screen_ctx.beginPath();\n        window.screen_ctx.moveTo($0, $1);\n        window.screen_ctx.lineTo($0 + $2 - 1, $1);\n        ctx.stroke();\n    }, pen_x, pen_y, length);\n}\n\nvoid drawVLine(unsigned short length) {\n\n    EM_ASM_({\n        window.screen_ctx.beginPath();\n        window.screen_ctx.moveTo($0, $1);\n        window.screen_ctx.lineTo($0, $1 + $2 - 1);\n    }, pen_x, pen_y, length);\n}\n\nvoid drawRect(unsigned short width, unsigned short height) {\n\n    EM_ASM_({\n        window.screen_ctx.rect($0, $1, $2, $3);\n        window.screen_ctx.stroke();\n    }, pen_x, pen_y, width, height);\n}\n\nvoid fillRect(unsigned short width, unsigned short height) {\n\n    EM_ASM_({\n        window.screen_ctx.fillRect($0, $1, $2, $3);\n    }, pen_x, pen_y, width, height);\n}\n\nvoid drawChar(char c) {\n\n    int j, i;\n    unsigned int old_x, old_y;\n    unsigned char line;\n\n    c = c & 0x7F; //Reduce to base ASCII set\n    old_x = pen_x;\n    old_y = pen_y;\n\n    for(i = 0; i < 12; i++) {\n\n        line = font_array[i * 128 + c];\n        for(j = 0; j < 8; j++) {\n\n            if(line & 0x80) {\n                pen_x = old_x + j;\n                pen_y = old_y + i;\n                setPixel();\n            }\n\n            line = line << 1;\n        }\n    }\n    \n    pen_x = old_x;\n    pen_y = old_y;\n}\n\nvoid drawStr(char* str) {\n\n    //Not implemented in production code, so not implemented here\n}\n\nbitmap* newBitmap(unsigned int width, unsigned int height) {\n    \n    unsigned int bmp_size = width * height;\n    unsigned int bufsz = (bmp_size *  sizeof(unsigned int)) + sizeof(bitmap);\n    bitmap* return_bmp;\n    unsigned int i;\n        \n    if(!(return_bmp = (bitmap*)malloc(bufsz)))\n        return (bitmap*)0;\n    \n    //Set dimensions    \n    return_bmp->height = height;\n    return_bmp->width = width;\n    \n    //Default the window to max\n    return_bmp->top = 0;\n    return_bmp->left = 0;\n    return_bmp->bottom = return_bmp->height;\n    return_bmp->right = return_bmp->width;\n    \n    //Plug in the data region\n    return_bmp->data = (unsigned int*)((unsigned char*)return_bmp + sizeof(bitmap));\n    \n    //Clear the bitmap\n    for(i = 0; i < bmp_size; i++) {\n            \n        return_bmp->data[i] = 0;\n    }\n        \n    return return_bmp;\n}\n\nvoid freeBitmap(bitmap* bmp) {\n    \n    free((void*)bmp);\n}\n\nvoid drawBitmap(bitmap* bmp) {\n        \n    int width = bmp->right - bmp->left + 1;\n    int height = bmp->bottom - bmp->top + 1; \n\n    if(width <= 0 || height <= 0)\n        return;\n    \n    EM_ASM_({\n        //console.log(\"new ImageData(\"+$0+\", \"+$1+\");\");\n        window.imgdata = new ImageData($0, $1);\n    }, width, height);\n\n    int srcx, srcy;\n    unsigned int color;\n\n    for(srcy = 0; srcy < height; srcy++) {\n        for(srcx = 0; srcx < width; srcx++) {\n      \n             color = bmp->data[(srcx + bmp->left) + ((srcy + bmp->top) * bmp->width)];\n             \n             EM_ASM_({\n                 var i = ($1 + ($2 * $0)) * 4;\n                 window.imgdata.data[i + 0] = $3;\n                 window.imgdata.data[i + 1] = $4;\n                 window.imgdata.data[i + 2] = $5;\n                 window.imgdata.data[i + 3] = 255;\n             }, width, srcx, srcy, RVAL(color), GVAL(color), BVAL(color));\n        }\n    }\n\n    EM_ASM_({\n        //console.log(\"drawing bitmap at (\" + $0 + \", \" + $1 + \")\");\n        window.screen_ctx.putImageData(window.imgdata, $0, $1);\n    }, pen_x + bmp->left, pen_y + bmp->top);\n}\n\nvoid copyScreen(bitmap* bmp) {\n    \n    //Not implemented yet (semi-large pita)\n    /*\n    unsigned int color;\n    \n    pixrect.x = pen_x;\n    pixrect.y = pen_y;\n    pixrect.w = bmp->width;\n    pixrect.h = bmp->height;\n    \n    SDL_RenderReadPixels(renderer, &pixrect, SDL_PIXELFORMAT_ARGB8888, (void*)(bmp->data), 4*pixrect.w);\n    */\n}\n","//This is the test harness version of the P5 lib\n#include <emscripten.h>\n#include \"../p5-redux/P5OSPPB/mods/include/p5.h\"\n#include <stdlib.h>\n#include <stdio.h>\n\nint getMessage(message* msg) {\n    \n    //We don't emulate message passing\n    return 1;\n}\n\n\nint getMessageFrom(message* msg, unsigned int source, unsigned int command) {\n\n    //We don't emulate message passing\n    return 1;\n}\n\n\nvoid postMessage(unsigned int ldest, unsigned int lcommand, unsigned int lpayload)  {\n\n    //We don't emulate message passing\n}\n\nvoid resetPidSearch() {\n\n}\n\nunsigned int getNextPid() {\n\n    return 0;\n}\n\nunsigned int getCurrentPid() {\n\n    return 0;\n}\n\nunsigned int getProcessCPUUsage(unsigned int pid) {\n\n    return 100;\n}\n\nunsigned int registerIRQ(unsigned int irq_number) {\n\n    //We don't do IRQs, they will never work\n    return 0;\n}\n\n//Sleep the process until the kernel passes it an interrupt message\nvoid waitForIRQ(unsigned int irq_number) {\n\n    while(1);\n}\n\nvoid pchar(char c) {\n\n    putchar(c);\n}\n\n\nvoid terminate(void) {\n\n}\n\nint initMouse() {\n\n    //Setup a function that stores mouse movement events \n    //into a buffer every time the mouse move event fires\n    //on our canvas object\n    EM_ASM(\n        if(window.mchange === undefined) {\n            window.mchange = false;\n            window.mouse = {x: 0, y: 0, down: 0};\n        }\n\n        var canvas = document.getElementById('screen_canvas');\n\n        canvas.addEventListener('mousemove', function(event) {\n            \n            var rect = canvas.getBoundingClientRect();\n\n            window.mchange = true;\n            window.mouse = {x: event.clientX - rect.left, y: event.clientY - rect.top, down: window.mouse.down}; \n        });\n\n        canvas.addEventListener('mousedown', function(event) {\n        \n            window.mchange = true;\n            window.mouse = {x: window.mouse.x, y: window.mouse.y, down: true};\n        });\n\n        canvas.addEventListener('mouseup', function(event) {\n        \n            window.mchange = true;\n            window.mouse = {x: window.mouse.x, y: window.mouse.y, down: false}; \n        });\n    );\n\n    return 1;\n}\n\nint checkMouse(int *x, int *y, unsigned char* buttons) {\n\n    if(!EM_ASM_INT({ if(window.mchange) return 1; else return 0; }, 0))\n        return 0;\n\n    *x = EM_ASM_INT({ return window.mouse.x }, 0);\n    *y = EM_ASM_INT({ return window.mouse.y }, 0);\n    *buttons = EM_ASM_INT({ return window.mouse.down ? 1 : 0 }, 0); \n\n    EM_ASM(window.mchange = false;);\n\n    return 1;\n}\n\nint initKey() {\n\n    //Setup a function that places key codes into a buffer\n    //every time the key event fires on our canvas object\n    EM_ASM(\n        if(window.keyq === undefined)\n            window.keyq = []; \n\n        document.addEventListener('keydown', function(event) {\n            \n            window.keyq.push(event.keyCode);\n        });\n    );\n\n    return 1;\n}\n\nunsigned char getch() {\n\n    //Get the most recent character from the queue or zero\n    //if there are none\n    return (unsigned char)EM_ASM_INT({\n        if(window.keyq !== undefined && window.keyq.length > 0)\n            return window.keyq.shift();\n        else\n            return 0;\n    }, 0);\n}\n\n\nvoid clearScreen() {\n\n}\n\n\nunsigned int startProc(unsigned char* path) {\n\n    return 0;\n}\n\n\nunsigned int startSuperProc(unsigned char* path) {\n\n    return 0;\n}\n\n\nunsigned int startV86(unsigned char* path) {\n\n    return 0;\n}\n\nvoid prints(char* s) {\n\n    int index = 0;\n\n    while(s[index] != 0) {\n        pchar(s[index]);\n        index++;\n    }\n}\n\nunsigned char digitToHex(unsigned char digit) {\n\n    if(digit < 0xA) {\n        return (digit + '0');\n    } else {\n        return ((digit - 0xA) + 'A');\n    }\n}\n\n\nvoid printHexByte(unsigned char byte) {\n\n    pchar(digitToHex((byte & 0xF0)>>4));\n    pchar(digitToHex(byte & 0xF));\n}\n\n\nvoid printHexWord(unsigned short wd) {\n\n    printHexByte((unsigned char)((wd & 0xFF00)>>8));\n    printHexByte((unsigned char)(wd & 0xFF));\n}\n\n\nvoid printHexDword(unsigned int dword) {\n\n    printHexWord((unsigned short)((dword & 0xFFFF0000)>>16));\n    printHexWord((unsigned short)(dword & 0xFFFF));\n}\n\n\nunsigned int getBuildNumber(void) {\n\n    return 0;\n}\n\nvoid* allocatePhysical(void* base_address, unsigned int byte_count) {\n\n    return malloc(byte_count);\n}\n\nunsigned char freePhysical(void* base_address, unsigned int byte_count) {\n\n    free(base_address);\n    return 1;\n}\n\nvoid* getSharedPages(unsigned int count) {\n\n    return malloc(count*4096);\n}\n\nvoid freeSharedPages(void* base) {\n    \n    free(base);\n}\n\nvoid* getSharedPage(void) {\n\n    return malloc(4096);\n}\n\n/*\nunsigned int sleep(unsigned int ms) {\n\n    //Maybe I'll figure this out later\n    return 1;\n}\n*/\n\nunsigned int getImageSize(unsigned int pid) {\n\n    return 0;\n}\n\nunsigned int appendPage(void) {\n\n    return 1;\n}\n\nvoid printDecimal(unsigned int dword) {\n\n    unsigned char digit[12];\n    int i, j;\n\n    i = 0;\n    while(1) {\n\n        if(!dword) {\n\n            if(i == 0)\n                digit[i++] = 0;\n\n            break;\n        }\n\n        digit[i++] = dword % 10;\n        dword /= 10;\n    }\n\n    for(j = i - 1; j >= 0; j--)\n        pchar(digit[j] + '0');\n}\n\nvoid sendString(unsigned char* s, unsigned int dest) {\n\n    //don't implement\n}\n\nunsigned int getStringLength(unsigned int src) {\n    \n    //don't implement\n    return 0;\n}\n\nvoid getString(unsigned int src, unsigned char* outstring, unsigned int count) {\n    \n    //Don't implement\n}\n","#include <emscripten.h>\n#include <stdio.h>\n#include <string.h>\n#include \"../p5-redux/P5OSPPB/mods/include/key.h\"\n#include \"../p5-redux/P5OSPPB/mods/include/wyg.h\"\n#include \"../p5-redux/P5OSPPB/mods/include/p5.h\"\n#include \"../p5-redux/P5OSPPB/mods/include/gfx.h\"\n\n#undef main\n\n//This way we get access to the entry point of WYG\nextern void WYG_main(void);\nextern unsigned char font_array[];\nextern int initMouse(void);\nextern int checkMouse(int* x, int* y, unsigned char *buttons);\nextern void putMouse(int x, int y, unsigned char buttons);\n\ntypedef struct window {\n    unsigned char flags;\n    unsigned int handle;\n    unsigned int pid;\n    bitmap* context;\n    struct window* next_sibling;\n    struct window* parent; \n    struct window* first_child;\n    unsigned int w;\n    unsigned int h;\n    unsigned int x;\n    unsigned int y;\n    unsigned char needs_redraw;\n    unsigned char* title;\n    unsigned char frame_needs_redraw;\n} window;\n\nint off_top, off_left, off_bottom, off_right;\n\nint main(int argc, char** argv) {\n\t\n\tWYG_main();\n\t\n\treturn 0;\n}\n\n#define CMD_COUNT 8\n\n//Function declarations\nint usrClear(void);\nint consVer(void);\nint usrExit(void);\nint makeChild(void);\nint closeChild(void);\nint focusCmd(void);\nint moveChild(void);\nint moveMe(void);\nvoid cmd_pchar(unsigned char c);\nvoid cmd_prints(unsigned char* s);\nvoid cmd_clear();\nvoid cmd_init(unsigned int win);\nvoid cmd_getCursor(unsigned char *x, unsigned char *y);\nvoid cmd_putCursor(unsigned char x, unsigned char y);\nvoid cmd_printHexByte(unsigned char byte);\nvoid cmd_printHexWord(unsigned short wd);\nvoid cmd_printHexDword(unsigned int dword);\nvoid cmd_printDecimal(unsigned int dword);\nvoid cmd_scans(int c, char* b);\n\n//Typedefs\ntypedef int (*sys_command)(void);\n\n//Variable declarations\nchar* cmdWord[CMD_COUNT] = {\n    \"CLR\",\n    \"VER\",\n    \"EXIT\",\n    \"WIN\",\n    \"CLOSE\",\n    \"FOCUS\",\n    \"MOV\",\n    \"MOVME\"\n};\n\nsys_command cmdFunc[CMD_COUNT] = {\n    (sys_command)&usrClear,\n    (sys_command)&consVer,\n    (sys_command)&usrExit,\n    (sys_command)&makeChild,\n    (sys_command)&closeChild,\n    (sys_command)&focusCmd,\n    (sys_command)&moveChild,\n    (sys_command)&moveMe\n};\n\nchar inbuf[50];\n\nint parse(char* cmdbuf) {\n\n    int i, found;\n\n    found = 0;\n    for(i = 0; i < CMD_COUNT; i++) {\n\n        if(!strcmp(cmdWord[i], cmdbuf)) {\n\n            return cmdFunc[i]();\n        }\n    }\n\n    cmd_prints(\"Unknown command \");\n    cmd_prints(cmdbuf);\n    cmd_prints(\"\\n\");\n    \n    return 0;\n}\n\nunsigned int window_a = 0, window_b = 0;\n\nint focusCmd() {\n    \n    focus(window_a);\n    return 0;\n}\n\nunsigned int winx, winy;\n\nint moveChild() {\n    \n    if(!window_b) {\n        \n        cmd_prints(\"No window\\n\");\n        return 0;\n    }   \n    \n    winx += 20;\n    winy += 20;\n    moveHandle(window_b, winx, winy);\n    \n    return 0;\n}\n\nint moveMe() {\n\n    static int moved = 0;\n\n    if(!moved)\n        moveHandle(window_a, 0, 0);\n    else\n        moveHandle(window_a, 54, 66);\n\n    moved = !moved;\n}\n\nint makeChild() {\n    \n    bitmap* ctx_b;\n    int x, y;\n    unsigned int tile_width = 4;\n    unsigned int tile_height = 4;\n    unsigned int tile_data[] = {\n        0x00000000, 0x00000000, 0x00000000, 0xFFFFFFFF,\n        0x00000000, 0xFFFFFFFF, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0xFFFFFFFF, 0x00000000,\n        0xFFFFFFFF, 0x00000000, 0x00000000, 0x00000000\n    };\n    \n    winx = 100;\n    winy = 20;\n    \n    if(window_b) {\n        \n        cmd_prints(\"Raising window\\n\");\n        focus(window_b);\n        return 0;\n    }    \n    \n    cmd_prints(\"Creating window\\n\");\n    \n    window_b = createWindow(400, 400, WIN_FIXEDSIZE);\n    \n    //Set up their titles\n    setTitle(window_b, \"Window B\");\n    \n    //Install them into the root window\n    installWindow(window_b, ROOT_WINDOW);\n\n//Gotta calculate frame dimensions here\n    \n    //Paint a pretty picture into window A\n    ctx_b = getWindowContext(window_b);\n    \n    //This SHOULD tile the tile image across the window\n    for(x = 0; x < 400 - off_left - off_right; x++)\n        for(y = 0; y < 400 - off_top - off_bottom; y++)\n            ctx_b->data[(y+off_top)*(400) + (x+off_left)] = tile_data[(y%tile_height)*tile_width + (x%tile_width)];\n    \n    //Make them prettily cascade\n    moveHandle(window_b, 100, 20);\n    \n    //Make them visible\n    showWindow(window_b);\n    \n    return 0;\n}\n\nint closeChild() {\n    \n    if(window_b) {\n     \n        cmd_prints(\"Destroying window\\n\");   \n        destroyWindow(window_b);\n        window_b = 0;\n        return 0;\n    }\n    \n    cmd_prints(\"Window doesn't exist\\n\");\n    \n    return 0;\n}\n\nvoid input_loop();\n\nvoid makeWindows() {\n    \n    unsigned short w, h;\n\n    getFrameDims(&off_top, &off_left, &off_bottom, &off_right);\n        \n    //Make two windows\n    getWindowDimensions(ROOT_WINDOW, &w, &h);\n    \n    printf(\"Creating window\\n\");\n    window_a = createWindow(w - 108, h - 132, WIN_FIXEDSIZE);\n    \n    //Set up their titles\n    printf(\"Setting up title\\n\");\n    setTitle(window_a, \"PTerm\");\n    \n    //Install them into the root window\n    printf(\"Placing window into desktop\\n\");\n    installWindow(window_a, ROOT_WINDOW);\n        \n    //Make them prettily cascade\n    printf(\"Cascading window\\n\");\n    moveHandle(window_a, 54, 66);\n    \n    //Make them visible\n    printf(\"Showing window\\n\");\n    showWindow(window_a);\n        \n    //Set up the console commands\n    printf(\"Setting up console\\n\");\n    cmd_init(window_a);\n\n    initKey();\n    initMouse();\n    cmd_prints(\"::\");\n    \n    //Only for emscripten. Should be configurable via compiler directive\n    emscripten_set_main_loop(input_loop, 0, 1);\n\n/*\n    while(1) {\n\n        cmd_prints(\"::\");\n        prints(\"::\");\n        cmd_scans(50, inbuf);\n        \n        //If the command function returns 1 it signals that we need to exit\n        if(parse(inbuf))\n            break;\n    }\n*/\n}\n\nunsigned char temp_char = 0;\nint inbuf_ptr = 0;\nint finished = 0;\n\nvoid input_loop() {\n\n    int mouse_x, mouse_y;\n    unsigned char buttons;\n  \n    //prints(\"::\");\n    //cmd_scans(50, inbuf);\n\n    //Check the mouse\n    if(checkMouse(&mouse_x, &mouse_y, &buttons)) {\n       \n        putMouse(mouse_x, mouse_y, buttons);\n    }\n\n    temp_char = getch();\n\n    if(!temp_char)\n        return;\n\n    cmd_pchar(temp_char);\n\n    if(temp_char == 0xA || temp_char == 0xD || inbuf_ptr == 49) {\n\n        inbuf[inbuf_ptr] = 0;\n\n        //If the command function returns 1 it signals that we need to exit\n        if(parse(inbuf))\n            finished = 1;\n\n        inbuf[0] = 0;\n        inbuf_ptr = 0;\n        cmd_prints(\"::\");\n\n        if(finished)\n            emscripten_cancel_main_loop();\n    } else {\n\n        inbuf[inbuf_ptr++] = temp_char;\n    }\n}\n\nint usrClear(void) {\n\n    cmd_clear();\n    return 0;\n}\n\n\nint consVer(void) {\n\n    cmd_prints(\"P5 usermode console build 1\\n\");\n    cmd_prints(\"P5 build [need fmt print and P5 build number hook]\\n\");\n    return 0;\n}\n\n\nint usrExit(void) {\n\n    destroyWindow(window_a);\n    return 1;\n}\n\n//Wrapper for setting the blit mask for the window bitmap to a specific region before requesting redraw\nvoid repaintAll(unsigned int handle, bitmap* h_bmp) {\n    \n    //Set the blitting rect \n    h_bmp->top = 0;\n    h_bmp->left = 0;\n    h_bmp->bottom = h_bmp->height;\n    h_bmp->right = h_bmp->width;   \n    \n    //Redraw \n    repaintWindow(handle);\n}\n\n//Wrapper for setting the blit mask for the window bitmap to a specific region before requesting redraw\nvoid repaintRegion(unsigned int handle, bitmap* h_bmp, unsigned int x, unsigned int y, unsigned int w, unsigned int h) {\n\n    //Set the blitting rect \n    h_bmp->top = y;\n    h_bmp->left = x;\n    h_bmp->bottom = y + h;\n    h_bmp->right = x + w;   \n    \n    //Redraw \n    repaintWindow(handle); \n}\n\nbitmap* cmd_bmp;\nunsigned int cmd_window;\nunsigned char cmd_x;\nunsigned char cmd_y;\nunsigned short cmd_bx, cmd_by; \nint cmd_width;\nint cmd_height;\nint cmd_max_chars;\nint cmd_max_lines;\n\nvoid drawCharacter(bitmap* b, char c, int x, int y, unsigned int color) {\n   \n    int j, i;\n    unsigned char line;\n    c &= 0x7F; //Reduce to base ASCII set\n\n    for(i = 0; i < 12; i++) {\n\n        line = font_array[i * 128 + c];\n        for(j = 0; j < 8; j++) {\n\n            if(line & 0x80) b->data[(y + i)*b->width + (x + j)] = color;\n            line = line << 1;\n        }\n    }\n    \n    repaintRegion(cmd_window, cmd_bmp, x, y, 8, 12);\n}\n\n\nvoid drawCharacterBold(bitmap* b, char c, int x, int y, unsigned int color) {\n\n    drawCharacter(b, c, x, y, color);\n    drawCharacter(b, c, x+1, y, color);\n    drawCharacter(b, c, x, y+1, color);\n    drawCharacter(b, c, x+1, y+1, color);\n}\n\n\nvoid drawString(bitmap* b, char* str, int x, int y, unsigned int color) {\n\n    int i;\n\n    for(i = 0; str[i]; i++) \n        drawCharacter(b, str[i], x+(i*8), y, color);\n}\n\nvoid cmd_getCursor(unsigned char *x, unsigned char *y) {\n\n    *x = cmd_x;\n    *y = cmd_y;\n}\n\nvoid cmd_putCursor(unsigned char x, unsigned char y) {\n\n    cmd_x = x;\n    cmd_y = y;\n}\n\nvoid cmd_pchar(unsigned char c) {\n\n    if(c == '\\n') {\n\n        cmd_x = 0;\n        cmd_y++;\n    } else {\n        \n        putchar(c);\n        drawCharacter(cmd_bmp, c, (cmd_x*8) + off_left, (cmd_y*12) + off_top, RGB(0, 0, 0));\n        cmd_x++;\n\n        if(cmd_x > cmd_max_chars) {\n\n            cmd_x = 0;\n            cmd_y++;\n        }\n    }\n    \n    //Should update this so it only repaints the section\n    //of bitmap where the character was drawn    \n    if(cmd_y > cmd_max_lines)\n        cmd_clear();        \n}\n\nvoid cmd_prints(unsigned char* s) {\n\n    while(*s)\n        cmd_pchar(*s++);\n}\n\nvoid cmd_clear() {\n\n    unsigned int x, y;\n\n    for(y = 0; y < cmd_height; y++)\n        for(x = 0; x < cmd_width; x++)\n            cmd_bmp->data[(y+off_top)*cmd_bmp->width + (x+off_left)] = RGB(255, 255, 255);\n            \n    cmd_x = 0;\n    cmd_y = 0;\n    \n    repaintAll(cmd_window, cmd_bmp);\n    \n    //Now clear to green temporarily to see what's getting repainted and where\n    for(y = 0; y < cmd_height; y++)\n        for(x = 0; x < cmd_width; x++)\n            cmd_bmp->data[(y+off_top)*cmd_bmp->width + (x+off_left)] = RGB(0, 255, 0);\n}\n\nvoid cmd_printDecimal(unsigned int dword) {\n\n    unsigned char digit[12];\n    int i, j;\n\n    i = 0;\n    while(1) {\n\n        if(!dword) {\n\n            if(i == 0)\n                digit[i++] = 0;\n\n            break;\n        }\n\n        digit[i++] = dword % 10;\n        dword /= 10;\n    }\n\n    for(j = i - 1; j >= 0; j--)\n        cmd_pchar(digit[j] + '0');\n}\n\nvoid cmd_printHexByte(unsigned char byte) {\n\n    cmd_pchar(digitToHex((byte & 0xF0)>>4));\n    cmd_pchar(digitToHex(byte & 0xF));\n}\n\n\nvoid cmd_printHexWord(unsigned short wd) {\n\n    cmd_printHexByte((unsigned char)((wd & 0xFF00)>>8));\n    cmd_printHexByte((unsigned char)(wd & 0xFF));\n}\n\n\nvoid cmd_printHexDword(unsigned int dword) {\n\n    cmd_printHexWord((unsigned short)((dword & 0xFFFF0000)>>16));\n    cmd_printHexWord((unsigned short)(dword & 0xFFFF));\n}\n\nvoid cmd_scans(int c, char* b) {\n\n    unsigned char temp_char;\n    int index = 0;\n\n    for(index = 0 ; index < c-1 ; ) {\n        temp_char = getch();\n\n        if(temp_char != 0) {\n            b[index] = temp_char;\n            cmd_pchar(b[index]);\n\n            if(b[index] == '\\n') {\n                b[index] = 0;\n                break;\n            }\n\n            index++;\n\n            if(index == c-1)\n                cmd_pchar('\\n');\n        }\n    }\n\n    b[index+1] = 0;\n}\n\n\nvoid cmd_init(unsigned int win) {\n    \n    cmd_window = win;\n    cmd_bmp = getWindowContext(cmd_window);\n    cmd_x = 0;\n    cmd_y = 0;\n    //getWindowDimensions(win, &cmd_bx, &cmd_by);\n    cmd_width = cmd_bmp->width - (off_left + off_right);\n    cmd_height = cmd_bmp->height - (off_top + off_bottom);\n    cmd_max_chars = (cmd_width/8) - 1;\n    cmd_max_lines = (cmd_height/12) - 1;\n    cmd_clear();\n}\n\nvoid testMain() {\n\t\n\tmakeWindows();\n}\n"]}